{"version":3,"file":"error-handler.d.ts","sources":["error-handler.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Injector } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { NgxsExecutionStrategy } from '../execution/symbols';\n/**\n * This operator is used for piping the observable result\n * from the `dispatch()`. It has a \"smart\" error handling\n * strategy that allows us to decide whether we propagate\n * errors to Angular's `ErrorHandler` or enable users to\n * handle them manually. We consider following cases:\n * 1) `store.dispatch()` (no subscribe) -> call `handleError()`\n * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`\n * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`\n * 4) `toPromise()` without `catch` -> do `handleError()`\n * 5) `toPromise()` with `catch` -> don't `handleError()`\n */\nexport declare function ngxsErrorHandler<T>(internalErrorReporter: InternalErrorReporter, ngxsExecutionStrategy: NgxsExecutionStrategy): (source: Observable<T>) => Observable<{}>;\nexport declare class InternalErrorReporter {\n    private _injector;\n    /** Will be set lazily to be backward compatible. */\n    private _errorHandler;\n    constructor(_injector: Injector);\n    reportErrorSafely(error: any): void;\n}\n"]}